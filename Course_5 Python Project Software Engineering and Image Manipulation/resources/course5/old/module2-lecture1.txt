While you have spent a lot of time learning how to program in Python and the Jupyter environment, I want to zoom out a bit and talk about how we design, develop, and communicate to others how our software systems operate. If you walk into any Computer Science Professor's office or classroom you are bound to see whiteboards - an unconstrained space where we can diagram and draw relationships between pieces - often called components - of the software system we are building. We tend to refer to this practice as Software Egineering and, while I won't be giving you a detailed discussion of all of the methods of software engineering as a discipline, I did want to introduce you to one way in which you might diagram out your software solution. Even better, we have basic support for this right from within the Jupyter programming environment through the drawing extension so, instead of me giving you a bunch of slides, let's just jump into Jupyter and begin to diagram.

Now, you'll see that when you create a new diagram there are a number of different shapes you are provided with in the left hand side and, for this lecture, we're going to focus on the shapes listed under the table marked "UML" for Unified Modeling Language. The principle shape I want you to look for is the third one over, and this denotes a class, let's drag this over to our canvas. 

As you've learned in the prior courses, a class is an abstract representation of a concept that you want to create in your software. A class is abstract in that you don't generally create a new class, you instead use it as a blueprint or template for creating new objects. An object then has properties depending upon its class, but the specific values for those properties will differ between objects.

Let's design a little game, and I'm going to design one of my favorite kinds of games called a dungeon crawler. In this game you are an adventurer in a magical land who has stumbled upon the entrance to a cave and you need to explore the cave slaying the monsters you face, making choices in each cavern you walk into. So let's begin by creating some classes for the different kinds of game elements I spoke about.

We'll create a new class for the Adventurer, the Cave, and individual Rooms in the Cave. Now, in this game I want it to feel really personalized and compelling, so the Adventurer needs a name, some physical characteristics like strength, dexterity, and consistution, some hit points which will determine their ability to survive in the game, and then maybe the adventurer also has a bag which has some list of items in it. We add each one of these as an additional field in the second portion of the Class diagram.

Now, we're already stumbled and found one of the first benefits of diagraming out a software solution: it can uncover some of the concepts we are interested in modeling and haven't yet thought about. For instance we have this "bag" which is a list, but what is it a list of? I refered to these as Items, but there is no item class in python. Are these strings? Ints? Booleans? Well, no, these are objects, Item objects, which means we need a new Item class. Let's add that now. I'm going to make things pretty simple for this demo and just assume that the Item objects we have in our bag are some kind of weapons or spells which we might be able to use to defeat a monster, and thus the item has a name which is a string, and a minimum and maximum damage value for attacking a monster. Finally, I think when you find items in a cave they probably are pretty well worn and have some chance of being destroyed when you attack a monster, so let's add that as another field to the Item.

I want to keep things simple to begin with, and then we can iterate and build this diagram up as we think of more bits to add. To that end, I'm just going to model a Room as having two fields, a monster field and a treasure field. Now, the treasure will be an Item, and we already have that in our diagram, but we need to add another class for Monsters. I'll make it pretty basic, with just a Monster name, a number of hit_points, and an attack damage value. For the Cave we can start with it just having a list of Room objects which the adventurer will go through.

Ok, this is our first class diagram! You can see that through diagraming out the different classes you might want in your system you start to discover the bounds of the problem you are trying to solve. In this case we didn't think about modeling Items and Monsters right away, but it came to us as we started to think about the problem and draw it out for other people.

Now, we're going to have to turn all of this into code to actually make a working system, but I wanted to show you my process in thinking through the problem first. And, well, we haven't really thought through the problem enough yet. How does the game actually get played? Does the adventurer choose to move through rooms? Does the monster get to attack first? Can you grab treasure or just get it by coming into the room? We need to think through the sequence of events in our system, and this means we need to think a bit about the kinds of methods our classes will have. So let's tackle that in the next lecture.